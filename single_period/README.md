# 单周期 CPU 设计与实现

## 1. 项目概述

单周期 CPU 指的是一条指令的执行在一个时钟周期内完成，然后开始下一条指令的执行，即一条指令用一个时钟周期完成。

**地址总线**和**数据总线**均为 32 位

## 2. 指令集设计

从 MIPS-C 指令集中进行选择，因此每条指令为 32 位

### 2.1 R-R 运算指令 10 条

| 指令 | 功能描述 | opcode | funct | 微指令 |
|------|----------|--------|-------|--------|
| add  | 加 | 000000 | 100000 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0000 |
| sub  | 减 | 000000 | 100010 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0001 |
| and  | 与 | 000000 | 100100 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0010 |
| or   | 或 | 000000 | 100101 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0011 |
| xor  | 异或 | 000000 | 100110 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0100 |
| sll  | 逻辑左移 | 000000 | 000000 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0101 |
| srl  | 逻辑右移 | 000000 | 000010 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0110 |
| sra  | 算术右移 | 000000 | 000011 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=0111 |
| slt  | 带符号小于置1 | 000000 | 101010 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=1000 |
| sltu | 无符号小于置1 | 000000 | 101011 | reg_we=1, reg_dst=01, alu_src=0, mem_to_reg=00, alu_op=1001 |

### 2.2 R-I 运算指令 2 条

| 指令 | 功能描述 | opcode | 微指令 |
|------|----------|--------|--------|
| addi | 加立即数 | 001000 | reg_we=1, reg_dst=00, alu_src=1, mem_to_reg=00, alu_op=0000, sign_ext=1 |
| ori  | 或立即数 | 001101 | reg_we=1, reg_dst=00, alu_src=1, mem_to_reg=00, alu_op=0011, sign_ext=0 |

### 2.3 分支指令 2 条

| 指令 | 功能描述 | opcode | 微指令 |
|------|----------|--------|--------|
| beq  | 等于转移 | 000100 | branch=1, alu_src=0, alu_op=0001, sign_ext=1 |
| j    | 无条件跳转 | 000010 | jump=1 |

### 2.4 加载指令 1 条

| 指令 | 功能描述 | opcode | 微指令 |
|------|----------|--------|--------|
| lw   | 加载字 | 100011 | reg_we=1, reg_dst=00, alu_src=1, mem_to_reg=01, alu_op=1010, sign_ext=1 |

### 2.5 存储指令 1 条

| 指令 | 功能描述 | opcode | 微指令 |
|------|----------|--------|--------|
| sw   | 存储字 | 101011 | mem_we=1, alu_src=1, alu_op=1010, sign_ext=1 |

## 3. 模块实现

### 3.1 常量定义模块 (defines.v)

该模块定义了指令格式、常量、opcode、funct和ALU操作类型等，为其他模块提供统一的常量定义。

主要内容包括：
- 指令长度、数据长度、地址长度定义
- 寄存器堆大小和寄存器地址长度定义
- 指令格式位定义（R型、I型、J型）
- opcode定义
- funct定义
- ALU操作类型定义

### 3.2 寄存器堆模块 (register_file.v)

该模块实现了32个32位寄存器，支持同时读取两个寄存器和写入一个寄存器。

主要功能：
- 32个32位寄存器，其中$zero寄存器始终输出0
- 支持同时读取两个寄存器（rs和rt）
- 支持在时钟上升沿写入一个寄存器（写使能有效且写地址不为$zero）
- 异步读取，同步写入

### 3.3 ALU运算模块 (alu.v)

该模块实现了算术逻辑单元，支持算术运算、逻辑运算、移位操作和比较操作。

主要功能：
- 支持加法、减法、与、或、异或等算术逻辑运算
- 支持逻辑左移、逻辑右移、算术右移等移位操作
- 支持带符号比较和无符号比较
- 输出运算结果和零标志位（用于分支判断）

### 3.4 指令存储器模块 (instruction_memory.v)

该模块实现了只读的指令存储器，32位宽，按字寻址。

主要功能：
- 1024条指令的存储空间（4KB）
- 按字寻址，地址右移2位转换为字地址
- 异步读取，组合逻辑输出
- 初始化时所有指令为nop（空指令）

### 3.5 数据存储器模块 (data_memory.v)

该模块实现了可读可写的数据存储器，32位宽，按字寻址。

主要功能：
- 1024个字的存储空间（4KB）
- 按字寻址，地址右移2位转换为字地址
- 同步写入，异步读取
- 复位时所有数据清零

### 3.6 程序计数器模块 (program_counter.v)

该模块实现了程序计数器，存储当前指令的地址，并根据控制信号更新下一条指令的地址。

主要功能：
- 存储当前指令地址
- 根据控制信号（分支、跳转、零标志）计算下一条指令地址
- 正常顺序执行：PC = PC + 4
- 分支指令且条件满足：PC = PC + 4 + (imm_ext << 2)
- 跳转指令：PC = (PC + 4)的高4位 | (j_addr << 2)

### 3.7 控制单元模块 (control_unit.v)

该模块实现了控制单元，根据指令的opcode和funct字段生成各种控制信号。

主要功能：
- 解析指令的opcode和funct字段
- 生成寄存器堆写使能、数据存储器写使能、分支信号、跳转信号等
- 生成寄存器堆写地址选择、ALU第二个操作数选择、寄存器堆写数据来源选择等多路选择器控制信号
- 根据指令类型生成ALU操作类型
- 控制立即数符号扩展或零扩展

### 3.8 CPU顶层模块 (cpu.v)

该模块是CPU的顶层模块，连接了所有子模块，形成完整的数据通路。

主要功能：
- 连接所有子模块，形成完整的数据通路
- 实现立即数扩展逻辑
- 实现寄存器写地址选择、ALU第二个操作数选择、寄存器写数据来源选择等多路选择器
- 输出PC和指令信号用于调试

### 3.9 测试用例模块 (testbench.v)

该模块实现了CPU的测试用例，对每个指令进行至少一次测试。

主要功能：
- 生成时钟和复位信号
- 初始化指令存储器，加载测试指令
- 监控PC和指令执行情况
- 生成波形文件用于调试

## 4. 数据通路设计

单周期CPU的数据通路包括以下几个部分：

1. **取指阶段**：从指令存储器中读取当前PC指向的指令
2. **译码阶段**：解析指令，生成控制信号，读取寄存器堆中的操作数
3. **执行阶段**：在ALU中执行运算，计算地址或进行比较
4. **访存阶段**：如果是加载或存储指令，访问数据存储器
5. **写回阶段**：将运算结果或加载的数据写回寄存器堆

## 5. 指令执行过程

### 5.1 R型指令执行过程

1. 取指：从指令存储器读取指令
2. 译码：解析opcode=000000，根据funct字段生成控制信号
3. 执行：从寄存器堆读取rs和rt，在ALU中执行相应运算
4. 写回：将ALU结果写回寄存器rd

### 5.2 I型指令执行过程

1. 取指：从指令存储器读取指令
2. 译码：解析opcode，生成控制信号，读取寄存器rs，扩展立即数
3. 执行：在ALU中执行rs和扩展后立即数的运算
4. 写回：将ALU结果写回寄存器rt

### 5.3 分支指令执行过程

1. 取指：从指令存储器读取指令
2. 译码：解析opcode，生成控制信号，读取寄存器rs和rt
3. 执行：在ALU中计算rs - rt，根据结果更新PC
4. 无写回阶段

### 5.4 跳转指令执行过程

1. 取指：从指令存储器读取指令
2. 译码：解析opcode=000010，生成跳转信号
3. 执行：直接根据跳转地址更新PC
4. 无写回阶段

### 5.5 加载指令执行过程

1. 取指：从指令存储器读取指令
2. 译码：解析opcode=100011，生成控制信号，读取寄存器rs，扩展立即数
3. 执行：在ALU中计算rs + 扩展后立即数，得到内存地址
4. 访存：从数据存储器读取数据
5. 写回：将读取的数据写回寄存器rt

### 5.6 存储指令执行过程

1. 取指：从指令存储器读取指令
2. 译码：解析opcode=101011，生成控制信号，读取寄存器rs和rt，扩展立即数
3. 执行：在ALU中计算rs + 扩展后立即数，得到内存地址
4. 访存：将rt中的数据写入数据存储器
5. 无写回阶段

## 6. 测试结果

测试用例对每个指令进行了至少一次测试，包括：

1. R型指令：add, sub, and, or, xor, sll, srl, sra, slt, sltu
2. I型指令：addi, ori
3. 分支指令：beq, j
4. 加载指令：lw
5. 存储指令：sw

测试结果显示，所有指令都能正确执行，CPU的功能符合预期。

## 7. 总结

本项目实现了一个基于MIPS-C指令集的单周期CPU，支持16条基本指令，包括算术逻辑指令、加载存储指令和分支指令。CPU采用模块化设计，包括寄存器堆、ALU、指令存储器、数据存储器、程序计数器和控制单元等模块。

单周期CPU的优点是设计简单，易于理解和实现；缺点是时钟周期必须足够长，以容纳最长的指令执行时间，因此性能较低。

通过本项目的实现，加深了对CPU工作原理和指令执行过程的理解，掌握了数字逻辑设计和Verilog HDL编程的基本技能。