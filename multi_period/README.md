# 多周期 CPU 设计

从单周期 CPU 的基础上进行修改

## 指令执行阶段分析

### 1. R-R型运算指令（add, sub, and, or）
**阶段：5个周期**

1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：读取rs、rt寄存器，指令译码
3. **EX（执行）**：ALU执行相应的算术/逻辑运算
4. **MEM（访存）**：**跳过**（R-R指令不需要访存）
5. **WB（写回）**：将ALU结果写入rd寄存器

### 2. R-I型运算指令（addi, ori）
**阶段：5个周期**
1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：读取rs寄存器，立即数符号/零扩展
3. **EX（执行）**：ALU执行寄存器与立即数的运算
4. **MEM（访存）**：**跳过**（R-I指令不需要访存）
5. **WB（写回）**：将ALU结果写入rt寄存器

### 3. 加载指令（lw）
**阶段：5个周期**
1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：读取base寄存器，立即数符号扩展
3. **EX（执行）**：计算有效地址（base + offset）
4. **MEM（访存）**：从数据存储器读取数据
5. **WB（写回）**：将内存数据写入rt寄存器

### 4. 存储指令（sw）
**阶段：4个周期**
1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：读取base和rt寄存器，立即数符号扩展
3. **EX（执行）**：计算有效地址（base + offset）
4. **MEM（访存）**：将rt寄存器数据写入数据存储器
5. **WB（写回）**：**跳过**（sw指令不需要写回）

### 5. 分支指令（beq）
**阶段：3个周期**
1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：读取rs、rt寄存器，计算分支目标地址
3. **EX（执行）**：比较rs和rt，根据结果更新PC
4. **MEM（访存）**：**跳过**（beq不需要访存）
5. **WB（写回）**：**跳过**（beq不需要写回）

### 6. 跳转指令（j）
**阶段：2个周期**

1. **IF（取指）**：从指令存储器读取指令
2. **ID（译码）**：计算跳转地址，更新PC
3. **EX（执行）**：**跳过**（j指令直接跳转）
4. **MEM（访存）**：**跳过**
5. **WB（写回）**：**跳过**

## 阶段详细功能说明

### IF阶段（所有指令）
- PC输出到指令存储器地址
- 读取指令到IR（指令寄存器）
- PC ← PC + 4（计算下一条顺序指令地址）

### ID阶段（所有指令）
- 解析指令字段（opcode, rs, rt, rd, funct等）
- 读取寄存器堆（rs, rt）
- 立即数扩展（符号/零扩展）
- 计算分支/跳转目标地址

### EX阶段
- **运算指令**：ALU执行指定操作
- **访存指令**：计算内存有效地址
- **分支指令**：比较寄存器值，决定是否跳转

### MEM阶段
- **lw**：从内存读取数据
- **sw**：向内存写入数据
- **其他指令**：空操作（NOP）

### WB阶段
- **需要写回的指令**：将结果写入寄存器堆
- **不需要写回的指令**：跳过此阶段

## 关键设计要点

### 1. 阶段控制
- 需要状态机控制每个阶段的执行
- 不同指令在特定阶段可能是空操作

### 2. 数据通路调整
- 阶段间需要寄存器保存中间结果
- 控制信号需要正确传递到每个阶段

### 3. 存储器访问优化
- 指令和数据存储器可以分时复用
- 减少硬件资源需求

### 4. PC更新时机
- 正常顺序：IF阶段PC+4
- 分支指令：EX阶段更新PC
- 跳转指令：ID阶段更新PC

这样的阶段划分确保了不同复杂度的指令有不同的执行周期数，体现了多周期CPU的优势。
